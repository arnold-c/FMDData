import{_ as p,C as h,c as k,o as r,j as a,a as e,aA as l,G as t,w as n}from"./chunks/framework.DMixvBxr.js";const G=JSON.parse('{"title":"Cleaning Functions","description":"","frontmatter":{},"headers":[],"relativePath":"icar-cleaning.md","filePath":"icar-cleaning.md","lastUpdated":null}'),d={name:"icar-cleaning.md"},o={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""};function L(R,s,N,O,U,$){const i=h("Badge");return r(),k("div",null,[s[104]||(s[104]=a("h1",{id:"Cleaning-Functions",tabindex:"-1"},[e("Cleaning Functions "),a("a",{class:"header-anchor",href:"#Cleaning-Functions","aria-label":'Permalink to "Cleaning Functions {#Cleaning-Functions}"'},"â€‹")],-1)),a("details",o,[a("summary",null,[s[0]||(s[0]=a("a",{id:"FMDData.all_2019_cleaning_steps-Union{Tuple{T1}, Tuple{T1, T1}} where T1<:AbstractString",href:"#FMDData.all_2019_cleaning_steps-Union{Tuple{T1}, Tuple{T1, T1}} where T1<:AbstractString"},[a("span",{class:"jlbinding"},"FMDData.all_2019_cleaning_steps")],-1)),s[1]||(s[1]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[3]||(s[3]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">all_2019_cleaning_steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input_filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input_dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	output_filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;clean_</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$(input_filename)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output_dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> icar_cleaned_dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    load_format </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DataFrame</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>A wrapper function that runs all the cleaning steps for seroprevalence tables from the 2019 annual report that share the common format of states in each row and columns relating to serotype seroprevalence. For tables from later reports, use <a href="/FMDData.git/dev/icar-cleaning#FMDData.all_cleaning_steps-Union{Tuple{T1}, Tuple{T1, T1}} where T1&lt;:AbstractString"><code>all_cleaning_steps()</code></a></p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[2]||(s[2]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/wrapper-functions.jl#L117-L128",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),a("details",c,[a("summary",null,[s[4]||(s[4]=a("a",{id:"FMDData.all_cleaning_steps-Union{Tuple{T1}, Tuple{T1, T1}} where T1<:AbstractString",href:"#FMDData.all_cleaning_steps-Union{Tuple{T1}, Tuple{T1, T1}} where T1<:AbstractString"},[a("span",{class:"jlbinding"},"FMDData.all_cleaning_steps")],-1)),s[5]||(s[5]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[7]||(s[7]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">all_cleaning_steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input_filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input_dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	output_filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;clean_</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$(input_filename)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output_dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> icar_cleaned_dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    load_format </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DataFrame</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>A wrapper function that runs all the cleaning steps for seroprevalence tables that share the common format of states in each row and columns relating to serotype counts/seroprevalence. For tables that contain multiple rows for each state e.g., 2019 report tables which cover multiple years for a single state, use the relevant alternative wrapper functions <a href="/FMDData.git/dev/icar-cleaning#FMDData.all_2019_cleaning_steps-Union{Tuple{T1}, Tuple{T1, T1}} where T1&lt;:AbstractString"><code>all_2019_cleaning_steps()</code></a>.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[6]||(s[6]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/wrapper-functions.jl#L11-L21",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),a("details",g,[a("summary",null,[s[8]||(s[8]=a("a",{id:"FMDData.calculate_state_counts",href:"#FMDData.calculate_state_counts"},[a("span",{class:"jlbinding"},"FMDData.calculate_state_counts")],-1)),s[9]||(s[9]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[11]||(s[11]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calculate_state_counts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, allowed_serotypes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> default_allowed_serotypes)</span></span></code></pre></div><p>A wrapper function around the internal <a href="/FMDData.git/dev/internal#FMDData._calculate_state_counts-Tuple{Any, Any}"><code>_calculate_state_counts()</code></a> function to calculate the state/serotype specific counts based upon the state/serotype seroprevalence values and total state counts. See the documentation of <a href="/FMDData.git/dev/internal#FMDData._calculate_state_counts-Tuple{Any, Any}"><code>_calculate_state_counts()</code></a> for more details on the implementation.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[10]||(s[10]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/calculate-state-counts.jl#L5-L9",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),a("details",E,[a("summary",null,[s[12]||(s[12]=a("a",{id:"FMDData.calculate_state_seroprevalence-Union{Tuple{DataFrames.DataFrame}, Tuple{T}, Tuple{DataFrames.DataFrame, T}} where T<:AbstractVector{<:AbstractString}",href:"#FMDData.calculate_state_seroprevalence-Union{Tuple{DataFrames.DataFrame}, Tuple{T}, Tuple{DataFrames.DataFrame, T}} where T<:AbstractVector{<:AbstractString}"},[a("span",{class:"jlbinding"},"FMDData.calculate_state_seroprevalence")],-1)),s[13]||(s[13]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[15]||(s[15]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calculate_state_seroprevalence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, allowed_serotypes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> default_allowed_serotypes)</span></span></code></pre></div><p>A wrapper function around the internal <a href="/FMDData.git/dev/internal#FMDData._calculate_state_seroprevalence-Tuple{Any, Any}"><code>_calculate_state_seroprevalence()</code></a> function to calculate the state/serotype specific counts based upon the state/serotype seroprevalence values and total state counts. See the documentation of <a href="/FMDData.git/dev/internal#FMDData._calculate_state_seroprevalence-Tuple{Any, Any}"><code>_calculate_state_seroprevalence()</code></a> for more details on the implementation.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[14]||(s[14]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/calculate-state-seroprevalence.jl#L4-L8",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),a("details",u,[a("summary",null,[s[16]||(s[16]=a("a",{id:"FMDData.check_calculated_values_match_existing-Union{Tuple{DataFrames.DataFrame}, Tuple{T}, Tuple{DataFrames.DataFrame, T}} where T<:AbstractVector{<:AbstractString}",href:"#FMDData.check_calculated_values_match_existing-Union{Tuple{DataFrames.DataFrame}, Tuple{T}, Tuple{DataFrames.DataFrame, T}} where T<:AbstractVector{<:AbstractString}"},[a("span",{class:"jlbinding"},"FMDData.check_calculated_values_match_existing")],-1)),s[17]||(s[17]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[19]||(s[19]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_calculated_values_match_existing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowed_serotypes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> default_allowed_serotypes;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    digits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractVector{&lt;:AbstractString}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Check whether the provided values of counts and seroprevalence values match the corresponding values calculated.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[18]||(s[18]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/check-calculated-values.jl#L7-L15",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),a("details",y,[a("summary",null,[s[20]||(s[20]=a("a",{id:"FMDData.check_seroprevalence_as_pct",href:"#FMDData.check_seroprevalence_as_pct"},[a("span",{class:"jlbinding"},"FMDData.check_seroprevalence_as_pct")],-1)),s[21]||(s[21]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[23]||(s[23]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_seroprevalence_as_pct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if all seroprevalence columns are reported as a percentage, and not as a proportion.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[22]||(s[22]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/check-seroprevalence-values.jl#L8-L12",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),a("details",_,[a("summary",null,[s[24]||(s[24]=a("a",{id:"FMDData.clean_colnames",href:"#FMDData.clean_colnames"},[a("span",{class:"jlbinding"},"FMDData.clean_colnames")],-1)),s[25]||(s[25]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[27]||(s[27]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">clean_colnames</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, allowed_chars_reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Replace spaces and / with underscores, and (n) and (%) with &quot;count&quot; and &quot;pct&quot; respectively. <code>allowed_chars_reg</code> should be a negative match, where the default <code>r&quot;[^\\w]&quot;</code> matches to all non numeric/alphabetic/_ characters</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[26]||(s[26]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/clean-column-names.jl#L6-L10",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),a("details",F,[a("summary",null,[s[28]||(s[28]=a("a",{id:"FMDData.rename_aggregated_pre_post_counts",href:"#FMDData.rename_aggregated_pre_post_counts"},[a("span",{class:"jlbinding"},"FMDData.rename_aggregated_pre_post_counts")],-1)),s[29]||(s[29]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[31]||(s[31]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rename_aggregated_pre_post_counts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    original_regex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    substitution_string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubstitutionString</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Rename the aggregated pre/post counts to use the same format as the serotype-specific values</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[30]||(s[30]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/clean-column-names.jl#L45-L53",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),a("details",D,[a("summary",null,[s[32]||(s[32]=a("a",{id:"FMDData.check_duplicated_column_names-Tuple{DataFrames.DataFrame}",href:"#FMDData.check_duplicated_column_names-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.check_duplicated_column_names")],-1)),s[33]||(s[33]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[35]||(s[35]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_duplicated_column_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    metric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Levenshtein</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    min_score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.79</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Union{&lt;:Metric, &lt;:SemiMetric}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Wrapper function around the two internal functions <a href="/FMDData.git/dev/internal#FMDData._check_identical_column_names-Tuple{DataFrames.DataFrame}"><code>_check_identical_column_names()</code></a> and <a href="/FMDData.git/dev/internal#FMDData._check_similar_column_names-Tuple{DataFrames.DataFrame}"><code>_check_similar_column_names()</code></a>. If a DataFrame is created then all identical column names should result in an error before it is created, but potentially they may be coerced to be made unique so a similarity check should be performed.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[34]||(s[34]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/column-name-checks.jl#L9-L17",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),a("details",b,[a("summary",null,[s[36]||(s[36]=a("a",{id:"FMDData.check_duplicated_columns-Tuple{DataFrames.DataFrame}",href:"#FMDData.check_duplicated_columns-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.check_duplicated_columns")],-1)),s[37]||(s[37]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[39]||(s[39]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_duplicated_columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if any columns have identical values</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[38]||(s[38]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/column-name-checks.jl#L92-L96",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[38]})]),a("details",m,[a("summary",null,[s[40]||(s[40]=a("a",{id:"FMDData.load_csv-Union{Tuple{T1}, Tuple{T1, T1}, Tuple{T1, T1, Any}} where T1<:AbstractString",href:"#FMDData.load_csv-Union{Tuple{T1}, Tuple{T1, T1}, Tuple{T1, T1, Any}} where T1<:AbstractString"},[a("span",{class:"jlbinding"},"FMDData.load_csv")],-1)),s[41]||(s[41]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[43]||(s[43]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">load_csv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output_format </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DataFrame</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>A helper function to check if a csv input file and directory exists, and if so, load (as a DataFrame by default).</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[42]||(s[42]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/file-management.jl#L8-L16",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[42]})]),a("details",C,[a("summary",null,[s[44]||(s[44]=a("a",{id:"FMDData.write_csv-Union{Tuple{T1}, Tuple{T1, T1, DataFrames.DataFrame}} where T1<:AbstractString",href:"#FMDData.write_csv-Union{Tuple{T1}, Tuple{T1, T1, DataFrames.DataFrame}} where T1<:AbstractString"},[a("span",{class:"jlbinding"},"FMDData.write_csv")],-1)),s[45]||(s[45]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[47]||(s[47]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_csv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>A helper function to check if the specified name and directory exist and are valid, and if so, write the CSV to disk.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[46]||(s[46]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/file-management.jl#L37-L45",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[46]})]),a("details",f,[a("summary",null,[s[48]||(s[48]=a("a",{id:"FMDData.check_aggregated_pre_post_counts_exist",href:"#FMDData.check_aggregated_pre_post_counts_exist"},[a("span",{class:"jlbinding"},"FMDData.check_aggregated_pre_post_counts_exist")],-1)),s[49]||(s[49]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[51]||(s[51]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_aggregated_pre_post_counts_exist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	columns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;serotype_all_count_pre&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;serotype_all_count_post&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if data contains aggregated counts of pre and post vaccinated individuals. Should only be used on dataframes that have renamed these columns to meet the standard pattern of &quot;serotype_all_count_pre&quot;</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[50]||(s[50]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/pre-post-checks.jl#L41-L48",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[50]})]),a("details",T,[a("summary",null,[s[52]||(s[52]=a("a",{id:"FMDData.check_pre_post_exists",href:"#FMDData.check_pre_post_exists"},[a("span",{class:"jlbinding"},"FMDData.check_pre_post_exists")],-1)),s[53]||(s[53]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[55]||(s[55]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_pre_post_exists</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Confirms each combination of serotype and result type (N/%) has both a pre- and post-vaccination results column, but nothing else.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[54]||(s[54]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/pre-post-checks.jl#L8-L12",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[54]})]),a("details",v,[a("summary",null,[s[56]||(s[56]=a("a",{id:"FMDData.select_calculated_cols!-Tuple{DataFrames.DataFrame}",href:"#FMDData.select_calculated_cols!-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.select_calculated_cols!")],-1)),s[57]||(s[57]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[59]||(s[59]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">select_calculated_cols!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowed_serotypes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, default_allowed_serotypes),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Checks if the data contains both provided and calculated columns that refer to the same variables. If the calculated column is a % seroprevalence, keep the calculated values. If the calculated column is a column of counts, keep the provided as they are deemed to be more accurate (counts require no calculation and should be a direct recording/reporting of the underlying data). The cleaning function <a href="/FMDData.git/dev/icar-cleaning#FMDData.check_calculated_values_match_existing-Union{Tuple{DataFrames.DataFrame}, Tuple{T}, Tuple{DataFrames.DataFrame, T}} where T&lt;:(AbstractVector{&lt;:AbstractString})"><code>check_calculated_values_match_existing()</code></a> should have been run before to ensure there are no surprises during this processing step i.e., accidentally deleting columns that should be retained.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[58]||(s[58]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/select-calculated-columns.jl#L6-L14",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[58]})]),a("details",A,[a("summary",null,[s[60]||(s[60]=a("a",{id:"FMDData.check_allowed_serotypes",href:"#FMDData.check_allowed_serotypes"},[a("span",{class:"jlbinding"},"FMDData.check_allowed_serotypes")],-1)),s[61]||(s[61]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[63]||(s[63]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_allowed_serotypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowed_serotypes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{String}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, default_allowed_serotypes),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> r&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">serotype_(.*)_(?|count|pct)_(pre|post)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Function to confirm that all required and no disallowed serotypes are provided in the data.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[62]||(s[62]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/serotype-checks.jl#L7-L15",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[62]})]),a("details",j,[a("summary",null,[s[64]||(s[64]=a("a",{id:"FMDData.sort_columns!-Tuple{DataFrames.DataFrame}",href:"#FMDData.sort_columns!-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.sort_columns!")],-1)),s[65]||(s[65]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[67]||(s[67]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sort_columns!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statename_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowed_serotypes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, default_allowed_serotypes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prefix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;serotype_&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    suffix_order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;_count_pre&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;_pct_pre&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;_count_post&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;_pct_post&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sort the columns of the cleaned dataframe to have a consistent order. Follows the pattern:</p><ul><li><p>state column name</p></li><li><p>serotype all counts (pre then post)</p></li><li><p>serotype specific columns in the order &quot;O&quot;, &quot;A&quot;, &quot;Asia1&quot;</p></li></ul><p>The serotype specific columns have their data presented in the following order.</p><ul><li><p>serotype X pre count</p></li><li><p>serotype X pre pct</p></li><li><p>serotype X post count</p></li><li><p>serotype X post pct</p></li></ul>`,5)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[66]||(s[66]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/sort-data.jl#L7-L32",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[66]})]),a("details",M,[a("summary",null,[s[68]||(s[68]=a("a",{id:"FMDData.sort_states!-Tuple{DataFrames.DataFrame}",href:"#FMDData.sort_states!-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.sort_states!")],-1)),s[69]||(s[69]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[71]||(s[71]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sort_states!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statename_column </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    totals_key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;total&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sort the dataframe by alphabetical order of the states and list the totals row at the bottom. Preserves the original order of rows if there are duplicates.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[70]||(s[70]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/sort-data.jl#L70-L78",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[70]})]),a("details",B,[a("summary",null,[s[72]||(s[72]=a("a",{id:"FMDData.check_duplicated_states",href:"#FMDData.check_duplicated_states"},[a("span",{class:"jlbinding"},"FMDData.check_duplicated_states")],-1)),s[73]||(s[73]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[75]||(s[75]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_duplicated_states</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if there are duplicated states in the data</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[74]||(s[74]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/state-checks.jl#L81-L88",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[74]})]),a("details",S,[a("summary",null,[s[76]||(s[76]=a("a",{id:"FMDData.check_missing_states",href:"#FMDData.check_missing_states"},[a("span",{class:"jlbinding"},"FMDData.check_missing_states")],-1)),s[77]||(s[77]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[79]||(s[79]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_missing_states</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if the states column of the data contains missing values</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[78]||(s[78]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/state-checks.jl#L64-L71",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[78]})]),a("details",x,[a("summary",null,[s[80]||(s[80]=a("a",{id:"FMDData.correct_all_state_names",href:"#FMDData.correct_all_state_names"},[a("span",{class:"jlbinding"},"FMDData.correct_all_state_names")],-1)),s[81]||(s[81]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[83]||(s[83]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">correct_all_state_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    states_dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FMDData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">states_dict</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Correct all state name values in the data</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[82]||(s[82]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/state-checks.jl#L8-L16",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[82]})]),a("details",w,[a("summary",null,[s[84]||(s[84]=a("a",{id:"FMDData.all_totals_check-Tuple{DataFrames.DataFrame}",href:"#FMDData.all_totals_check-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.all_totals_check")],-1)),s[85]||(s[85]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[87]||(s[87]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">all_totals_check</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    totals_key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowed_serotypes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, default_allowed_serotypes),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    atol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    digits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if all provided values in the provided totals row are correct. If the column is a count, then calculate an unweighted sum. If the column is the seroprevalence, calculated the sum weighted by the relevant counts (pre- or post-vaccination counts).</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[86]||(s[86]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/total-row-functions.jl#L33-L45",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[86]})]),a("details",q,[a("summary",null,[s[88]||(s[88]=a("a",{id:"FMDData.calculate_all_totals-Tuple{DataFrames.DataFrame}",href:"#FMDData.calculate_all_totals-Tuple{DataFrames.DataFrame}"},[a("span",{class:"jlbinding"},"FMDData.calculate_all_totals")],-1)),s[89]||(s[89]=e()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[91]||(s[91]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calculate_all_totals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    totals_key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowed_serotypes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, default_allowed_serotypes),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Regex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    digits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate all totals using the appropriate method instance of the internal function <a href="/FMDData.git/dev/internal#FMDData._calculate_totals!-Union{Tuple{T}, Tuple{OrderedCollections.OrderedDict, Vector{T}, String}} where T&lt;:(Union{var&quot;#s74&quot;, var&quot;#s73&quot;} where {var&quot;#s74&quot;&lt;:(Union{var&quot;#s72&quot;, var&quot;#s71&quot;} where {var&quot;#s72&quot;&lt;:Missing, var&quot;#s71&quot;&lt;:Integer}), var&quot;#s73&quot;&lt;:Integer})"><code>_calculate_totals!()</code></a>, dependent on whether the column is a Float (seroprevalence) or Integer (count). Uses the internal function <a href="/FMDData.git/dev/internal#FMDData._collect_totals_check_args-Union{Tuple{T}, Tuple{Vector{T}, String, Vararg{Any}}} where T&lt;:Union{Missing, Integer}"><code>_collect_totals_check_args()</code></a> to identify what arguments need to be passed to <a href="/FMDData.git/dev/internal#FMDData._calculate_totals!-Union{Tuple{T}, Tuple{OrderedCollections.OrderedDict, Vector{T}, String}} where T&lt;:(Union{var&quot;#s74&quot;, var&quot;#s73&quot;} where {var&quot;#s74&quot;&lt;:(Union{var&quot;#s72&quot;, var&quot;#s71&quot;} where {var&quot;#s72&quot;&lt;:Missing, var&quot;#s71&quot;&lt;:Integer}), var&quot;#s73&quot;&lt;:Integer})"><code>_calculate_totals!()</code></a> function. Uses the internal function <a href="/FMDData.git/dev/internal#FMDData._totals_row_selectors"><code>_totals_row_selectors()</code></a> to extract the totals row from the dataframe, for use when calculating the serotype weight total seroprevalence.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[90]||(s[90]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/total-row-functions.jl#L106-L117",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[90]})]),a("details",V,[a("summary",null,[s[92]||(s[92]=a("a",{id:"FMDData.has_totals_row",href:"#FMDData.has_totals_row"},[a("span",{class:"jlbinding"},"FMDData.has_totals_row")],-1)),s[93]||(s[93]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[95]||(s[95]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_totals_row</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    possible_keys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;totals&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if the table has a totals row.</p><p><code>df</code> should have, at the very least, cleaned column names using the <a href="/FMDData.git/dev/icar-cleaning#FMDData.clean_colnames"><code>clean_colnames()</code></a> function.</p>`,3)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[94]||(s[94]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/total-row-functions.jl#L11-L21",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[94]})]),a("details",I,[a("summary",null,[s[96]||(s[96]=a("a",{id:"FMDData.select_calculated_totals!",href:"#FMDData.select_calculated_totals!"},[a("span",{class:"jlbinding"},"FMDData.select_calculated_totals!")],-1)),s[97]||(s[97]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[99]||(s[99]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">select_calculated_totals!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :states_ut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	totals_key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	calculated_totals_key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;total calculated&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If the cleaned data contains both a provided and a calculated totals row then return strip the provided one and rename the calculated.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[98]||(s[98]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/total-row-functions.jl#L297-L306",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[98]})]),a("details",P,[a("summary",null,[s[100]||(s[100]=a("a",{id:"FMDData.totals_check",href:"#FMDData.totals_check"},[a("span",{class:"jlbinding"},"FMDData.totals_check")],-1)),s[101]||(s[101]=e()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[103]||(s[103]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">totals_check</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    col</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    provided_total,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    colname</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Union{&lt;:Union{&lt;:Missing, &lt;:Integer}, &lt;:Integer}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Check if the provided total counts equal the sum calculated using the provided state counts.</p>`,2)),t(i,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[102]||(s[102]=[a("a",{href:"https://github.com/arnold-c/FMDData/blob/8a6d7e089daacea4d171b1fde1018bbb70a830dc/src/icar-cleaning/total-row-functions.jl#L265-L273",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[102]})])])}const J=p(d,[["render",L]]);export{G as __pageData,J as default};
